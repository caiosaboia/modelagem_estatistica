---
title: "Trabalho Final"
subtitle: "Modelagem Estatística"
author: 
  - name: Caio Rubem Saboia Monteiro
  - name: Rogerio Ferreira Rodrigues Junior
# date: "dd/mm/aaaa" #if necessary
format:
  html:
    toc: TRUE
    number-sections: TRUE
    # toc-location: right-body
    code-fold: FALSE
    # css: styles.css #if necessary
    math: mathjax

  pdf:
    number-sections: true
    toc: true
    keep_tex: true

latex-engine: xelatex

# header-includes:
#   - \usepackage{amsmath}
#   - \usepackage{amsfonts}
#   - \usepackage{amssymb}
#   - \usepackage{listings}

execute:
  cache: true
  enabled: true
  freeze: true #can be use 'false' or auto
  echo: true
  # daemon: false #default is 300, but can use boleean values too 

#python
jupyter: python3 #can be use for Julia too
  # or can be use something like this:
  # kernelspec:
  #   name: "xpython"
  #   language: "python"
  #   display_name: "Python 3.7 (XPython)"

#R
knitr:
  opts_chunk:
    collapse: true
    comment: " >>"
    R.options:
      knitr.graphics.auto_pdf: true

# engine: julia # for more aplicatoins use quarto.org or :QuartoHelp Julia
---
# Bibliotecas
```{r}
library(lmtest)
library(lme4)
library(ggplot2)
library(dplyr)
library(tidyr)
library(readr)
library(stringr)
```


# Qualidade do Ar

## Estudo sobre a base de dados
```{r}
airquality_data <- read.csv("data/airquality.csv")
head(airquality_data)
```
```{r}
summary(airquality)
```
```{r}
# Ajustar o tamanho do gráfico na célula do notebook
options(repr.plot.width = 12, repr.plot.height = 8)

# Gráfico de relação entre as variáveis
pairs(airquality, main = "Gráfico de Relação entre Variáveis",
      lower.panel = panel.smooth, upper.panel = NULL)
```
```{r}
#| panel: full
# Ajustar o tamanho do gráfico na célula do notebook
options(repr.plot.width = 8, repr.plot.height = 8)

# Aplicação de um modelo de regressão linear
model_airquality = lm(Ozone ~., data=airquality)

# Gráficos de resíduos
par(mfrow = c(2, 2))
plot(model_airquality)

# Coeficiente de Determinação (R²) com uma mensagem explicativa
cat("O coeficiente de determinação (R²) do modelo é:", round(summary(model_airquality)$r.squared, 4), "\n")

summary(model_airquality)
```

```{r}
bptest(model_airquality)
```

```{r}
# Ajustar o tamanho do gráfico na célula do notebook
options(repr.plot.width = 8, repr.plot.height = 8)

airquality_mod <- airquality%>%mutate(Month=factor(Month))
# airquality_mod <- airquality_mod%>%mutate(Day=factor(Day))
airquality_mod <- airquality_mod%>%drop_na
# Aplicação de um novo modelo de regressão linear
model_airquality = lm(log(Ozone) ~., data=airquality_mod)

# Gráficos de resíduos
par(mfrow = c(2, 2))
plot(model_airquality)

# Coeficiente de Determinação (R²) com uma mensagem explicativa
cat("O coeficiente de determinação (R²) do modelo é:", round(summary(model_airquality)$r.squared, 4), "\n")

summary(model_airquality)
```

```{r}
bptest(model_airquality)
```

# Qualidade do Sono


```{r}
sleep_data <- read_csv("data/sleep.csv")
head(sleep_data)
```


```{r}
summary(sleep_data)
```


```{r}
# Ajustar o tamanho do gráfico na célula do notebook
options(repr.plot.width = 12, repr.plot.height = 8)

# Gráfico de relação entre as variáveis
pairs(sleep_data, main = "Gráfico de Relação entre Variáveis",
      lower.panel = panel.smooth, upper.panel = NULL)
```


```{r}
#| panel: full
# Ajustar o tamanho do gráfico na célula do notebook
options(repr.plot.width = 8, repr.plot.height = 8)

# airquality_mod <- airquality_mod%>%mutate(Day=factor(Day))
sleepstudy_mod <- sleep_data%>%drop_na

# Aplicação de um novo modelo de regressão linear
model_sleepstudy = lmer(Reaction ~ factor(Days) + (1|Subject),data=sleep_data)

# Gráficos de resíduos
par(mfrow = c(2, 2))
plot(model_sleepstudy)

# Coeficiente de Determinação (R²) com uma mensagem explicativa
#cat("O coeficiente de determinação (R²) do modelo é:", round(summary(model_sleepstudy)$r.squared, 4), "\n")

summary(model_sleepstudy)
```

# Metanalise

## Codigo em python para tratamento
```{python}
import pandas as pd
metanalise = pd.read_csv("data/metanalise.csv")
# Apaga a coluna de índices
metanalise = metanalise.drop("Unnamed: 0", axis=1)
metanalise.info()

```

```{python}
cluster = metanalise["cluster"]

names = []
years = []
"""
Para cada publicação na coluna (cluster):
- Quebra o texto para indentificar o autor e o ano
- Motivo_1: Buscar análise de um determinado autor pública mais viés de pesquisa.
- Motivo_2: Teve algum ano em que houve um boom de publicações com viés?
"""
for row in metanalise["cluster"]:
    name = ""
    year = ""
    for value_ in row.split(" "):
        # verifica se o valor é numérico.
        if value_.isnumeric():
           year = int(value_)
        # verifica se é numérico com letra.
        elif value_[:-1].isnumeric() and len(value_) == 5:
           year = int(value_[:-1])
        else:
           name += value_ + " "
    names.append(name)
    years.append(year)

# Salva os dados tratados em uma nova coluna
metanalise["autors"] = names
metanalise["pyears"] = years
# Elimina a coluna redundante
metanalise = metanalise.drop("cluster", axis=1)

```

```{python}
# Gera um novo arquivo com os dados modificados
metanalise.to_csv("metanalise_mod.csv", index=False)
```

```{python}
metanalise.hist()
```

## Analise dos dados no R
```{r}
library(tidyverse)
metanalise = read_csv("metanalise_mod.csv")
metanalise = metanalise %>% mutate(autors = factor(autors))
metanalise = metanalise %>% mutate(pyears = factor(pyears))
head(metanalise)
summary(metanalise)
```

```{r}
# Ajustar o tamanho do gráfico na célula do notebook
options(repr.plot.width = 8, repr.plot.height = 8)

# Aplicação de um modelo de regressão linear
model_metanalise = lm(yi ~  ., data=metanalise)

# Gráficos de resíduos
par(mfrow = c(2, 2))
plot(model_metanalise)

# Coeficiente de Determinação (R²) com uma mensagem explicativa
cat("O coeficiente de determinação (R²) do modelo é:", round(summary(model_metanalise)$r.squared, 4), "\n")

summary(model_metanalise)
```

```{r}
bptest(model_metanalise)
```



# Instagram

```{r}
instagram_data <- read_csv("data/instagram.csv")


convert_to_hours <- function(time_str) {
  time_str <- tolower(time_str)  # Converter para minúsculas
  horas <- as.numeric(str_extract(time_str, "\\d+(?= h)"))  # Pegar as horas
  minutos <- as.numeric(str_extract(time_str, "\\d+(?= min)"))  # Pegar os minutos
  
  # Substituir NA por 0 onde necessário
  horas[is.na(horas)] <- 0
  minutos[is.na(minutos)] <- 0
  
  # Converter para horas
  total_horas <- horas + (minutos / 60)
  return(total_horas)
}


dias_da_semana <- c("Segunda", "Terca", "Quarta", "Quinta", "Sexta", "Sabado", "Domingo")

instagram_data_2 <- instagram_data %>%
  mutate(across(all_of(dias_da_semana), convert_to_hours))



```


```{r}
glimpse(instagram_data_2)
head(instagram_data_2)

```

```{r}
instagram_long <- instagram_data_2 %>%
  pivot_longer(cols = c(Segunda:Domingo), names_to = "Dia", values_to = "Tempo")

# Criar histograma separado por dia
ggplot(instagram_long, aes(x = Tempo, fill = Dia)) +
  geom_histogram(bins = 10, color = "black", alpha = 0.7) +
  facet_wrap(~ Dia) +  # Cria um gráfico separado para cada dia
  labs(title = "Distribuição do Tempo de Uso do Instagram por Dia",
       x = "Tempo (horas)", y = "Frequência") +
  theme_minimal()
```


```{r}
# Transformar os dados para o formato longo
instagram_long <- tidyr::pivot_longer(instagram_data_2, cols = all_of(dias_da_semana),
                                      names_to = "Dia", values_to = "Tempo")

# Criar um boxplot para ver a distribuição do uso ao longo da semana
ggplot(instagram_long, aes(x = Dia, y = Tempo, fill = Dia)) +
  geom_boxplot() +
  labs(title = "Tempo de Uso do Instagram por Dia da Semana",
       x = "Dia da Semana", y = "Tempo (horas)") +
  theme_minimal()
```


```{r}
instagram_long %>%
  group_by(Dia) %>%
  summarise(Media_Tempo = mean(Tempo, na.rm = TRUE)) %>%
  ggplot(aes(x = Dia, y = Media_Tempo, fill = Dia)) +
  geom_bar(stat = "identity") +
  labs(title = "Média do Tempo de Uso do Instagram por Dia",
       x = "Dia da Semana", y = "Tempo médio (horas)") +
  theme_minimal()
```
